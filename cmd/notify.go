package cmd

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"time"

	"github.com/spf13/cobra"
)

var (
	address         net.IP
	appName         string
	backgroundColor string
	duration        time.Duration
	iconPath        string
	interrupt       bool
	message         string
	port            int64
	position        string
	title           string
	transparency    string
	hexColorRegex   = regexp.MustCompile("^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$")
)

var positions = map[string]int64{
	"bottom-right": 0,
	"bottom-left":  1,
	"top-right":    2,
	"top-left":     3,
	"center":       4,
}

var transparencies = map[string]int64{
	"default": 0,
	"0%":      1,
	"25%":     2,
	"50%":     3,
	"75%":     4,
	"100%":    5,
}

// notifyCmd represents the notify command
var notifyCmd = &cobra.Command{
	Use:   "notify",
	Short: "Sends a notification to Notifications for Android TV/Notifications for Fire TV.",
	Long:  "Sends a notification to Notifications for Android TV/Notifications for Fire TV.",
	Run: func(cmd *cobra.Command, args []string) {
		if err := notify(); err != nil {
			fmt.Println(err)
			os.Exit(-1)
		} else {
			fmt.Printf("notification sent to %s", address)
		}
	},
}

func init() {
	RootCmd.AddCommand(notifyCmd)

	// TODO: Disabled because behavior is unclear
	// notifyCmd.Flags().StringVarP(&offset, "offset", "o", "0", "XY offset from the position")

	notifyCmd.Flags().BoolVarP(&interrupt, "interrupt", "x", false, "If set, the notification is interactive and can be dismissed or selected to display more details. Depending on the running app (e.g. Netflix), this may stop playback.")
	notifyCmd.Flags().DurationVarP(&duration, "duration", "d", (5 * time.Second), "The duration in seconds for which the notification will be displayed.")
	notifyCmd.Flags().Int64VarP(&port, "port", "p", 7676, "Port to connect on")
	notifyCmd.Flags().IPVarP(&address, "address", "a", nil, "IP Address Notifications for Android TV or Notifications for Fire TV is running on.")
	notifyCmd.Flags().StringVarP(&appName, "app-name", "n", "nfa", "App name to display the notification as generated by")
	notifyCmd.Flags().StringVarP(&backgroundColor, "background-color", "b", "#607d8b", "Background color of the notification, given in hex format.")
	notifyCmd.Flags().StringVarP(&iconPath, "icon", "i", getDefaultImagePath(), "Path to icon")
	notifyCmd.Flags().StringVarP(&message, "message", "m", "Hello from nfa!", "Message to show")
	notifyCmd.Flags().StringVarP(&position, "position", "o", "bottom-right", "Position of the notification on screen. Must be one of bottom-right|bottom-left|top-right|top-left|center")
	notifyCmd.Flags().StringVarP(&title, "title", "t", "nfa", "Title of notification")
	notifyCmd.Flags().StringVarP(&transparency, "transparency", "s", "default", "Transparency percentage. Must be one of default|0%|25%|50%|75%|100%.")

}

func getDefaultImagePath() string {
	gopath := os.Getenv("GOPATH")
	if gopath == "" {
		gopath = defaultGOPATH()
	}
	return fmt.Sprintf("%s/src/github.com/robbiet480/nfa/gopher.png", gopath)
}

func defaultGOPATH() string {
	env := "HOME"
	if runtime.GOOS == "windows" {
		env = "USERPROFILE"
	} else if runtime.GOOS == "plan9" {
		env = "home"
	}
	if home := os.Getenv(env); home != "" {
		def := filepath.Join(home, "go")
		if filepath.Clean(def) == filepath.Clean(runtime.GOROOT()) {
			// Don't set the default GOPATH to GOROOT,
			// as that will trigger warnings from the go tool.
			return ""
		}
		return def
	}
	return ""
}

func notify() error {
	if address == nil {
		return errors.New("address must not be blank")
	}
	if iconPath == "" {
		iconPath = getDefaultImagePath()
	}

	posInt := int64(0)
	if pos, ok := positions[position]; ok {
		posInt = pos
	} else {
		return fmt.Errorf("%s is not a valid position", position)
	}

	transparencyInt := int64(0)
	if transp, ok := transparencies[transparency]; ok {
		transparencyInt = transp
	} else {
		return fmt.Errorf("%s is not a valid transparency", transparency)
	}

	if !hexColorRegex.MatchString(backgroundColor) {
		return fmt.Errorf("%s is not a valid hex color", backgroundColor)
	}

	var b bytes.Buffer
	w := multipart.NewWriter(&b)
	f, err := os.Open(iconPath)
	if err != nil {
		return err
	}
	defer func() {
		if fileErr := f.Close(); fileErr != nil {
			fmt.Println(fileErr)
			os.Exit(-1)
		}
	}()

	fw, err := w.CreateFormFile("filename", iconPath)
	if err != nil {
		return err
	}
	if _, err = io.Copy(fw, f); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("type"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte("0")); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("offset"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte("0")); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("position"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(strconv.FormatInt(posInt, 10))); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("transparency"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(strconv.FormatInt(transparencyInt, 10))); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("force"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte("true")); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("interrupt"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(strconv.FormatBool(interrupt))); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("bkgcolor"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(backgroundColor)); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("duration"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(strconv.FormatInt(int64(duration.Seconds()), 10))); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("app"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(appName)); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("title"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(title)); err != nil {
		return err
	}

	if fw, err = w.CreateFormField("msg"); err != nil {
		return err
	}
	if _, err = fw.Write([]byte(message)); err != nil {
		return err
	}

	if writerErr := w.Close(); writerErr != nil {
		return writerErr
	}

	url := fmt.Sprintf("http://%s", net.JoinHostPort(address.String(), strconv.FormatInt(port, 10)))
	req, err := http.NewRequest("POST", url, &b)
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", w.FormDataContentType())

	client := &http.Client{}
	res, err := client.Do(req)
	if err != nil {
		return err
	}

	if res.StatusCode != http.StatusOK {
		return fmt.Errorf("bad status: %s", res.Status)
	}
	return nil
}
